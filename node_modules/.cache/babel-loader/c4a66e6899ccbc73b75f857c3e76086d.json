{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport React from 'react';\nimport classNames from 'classnames';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar Range = /*#__PURE__*/function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  var _super = _createSuper(Range);\n\n  function Range(props) {\n    var _this;\n\n    _classCallCheck(this, Range);\n\n    _this = _super.call(this, props);\n    _this.startValue = void 0;\n    _this.startPosition = void 0;\n    _this.prevMovedHandleIndex = void 0;\n    _this.internalPointsCache = void 0;\n    _this.handlesRefs = void 0;\n    _this.dragTrack = void 0;\n\n    _this.positionGetValue = function (position) {\n      var bounds = _this.getValue();\n\n      var value = _this.calcValueByPos(position);\n\n      var closestBound = _this.getClosestBound(value);\n\n      var index = _this.getBoundNeedMoving(value, closestBound);\n\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[index] = value;\n      return nextBounds;\n    };\n\n    _this.onEnd = function (force) {\n      var handle = _this.state.handle;\n\n      _this.removeDocumentEvents();\n\n      if (!handle) {\n        _this.dragTrack = false;\n      }\n\n      if (handle !== null || force) {\n        _this.props.onAfterChange(_this.getValue());\n      }\n\n      _this.setState({\n        handle: null\n      });\n    };\n\n    var count = props.count,\n        min = props.min,\n        max = props.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n\n    var _value = props.value !== undefined ? props.value : defaultValue;\n\n    var _bounds = _value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: props\n      });\n    });\n\n    var recent = _bounds[0] === max ? 0 : _bounds.length - 1;\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: _bounds\n    };\n    return _this;\n  }\n\n  _createClass(Range, [{\n    key: \"calcValueByPos\",\n    value:\n    /**\n     * [Legacy] Used for inherit other component.\n     * It's a bad code style which should be refactor.\n     */\n\n    /* eslint-disable @typescript-eslint/no-unused-vars, class-methods-use-this */\n    function calcValueByPos(value) {\n      return 0;\n    }\n  }, {\n    key: \"getSliderLength\",\n    value: function getSliderLength() {\n      return 0;\n    }\n  }, {\n    key: \"calcOffset\",\n    value: function calcOffset(value) {\n      return 0;\n    }\n  }, {\n    key: \"saveHandle\",\n    value: function saveHandle(index, h) {}\n  }, {\n    key: \"removeDocumentEvents\",\n    value: function removeDocumentEvents() {}\n    /* eslint-enable */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          onChange = _this$props.onChange,\n          value = _this$props.value,\n          min = _this$props.min,\n          max = _this$props.max;\n\n      if (!('min' in this.props || 'max' in this.props)) {\n        return;\n      }\n\n      if (min === prevProps.min && max === prevProps.max) {\n        return;\n      }\n\n      var currentValue = value || prevState.bounds;\n\n      if (currentValue.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.props);\n      })) {\n        var newValues = currentValue.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.props);\n        });\n        onChange(newValues);\n      }\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['handle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _objectSpread(_objectSpread({}, this.state), state);\n\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(position) {\n      var props = this.props,\n          state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = _toConsumableArray(state.bounds);\n\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    }\n  }, {\n    key: \"onMove\",\n    value: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.state,\n          props = this.props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / (maxValue - minValue)), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n\n        return;\n      }\n\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    }\n  }, {\n    key: \"onKeyboard\",\n    value: function onKeyboard(e) {\n      var _this$props2 = this.props,\n          reverse = _this$props2.reverse,\n          vertical = _this$props2.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n            props = this.props;\n        var bounds = state.bounds,\n            handle = state.handle;\n        var oldValue = bounds[handle === null ? state.recent : handle];\n        var mutatedValue = valueMutator(oldValue, props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: handle,\n          bounds: state.bounds,\n          props: props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: \"getClosestBound\",\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    }\n  }, {\n    key: \"getBoundNeedMoving\",\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _this$state = this.state,\n          bounds = _this$state.bounds,\n          recent = _this$state.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    }\n  }, {\n    key: \"getLowerBound\",\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: \"getUpperBound\",\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n      return bounds[bounds.length - 1];\n    }\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      var _this$props3 = this.props,\n          marks = _this$props3.marks,\n          step = _this$props3.step,\n          min = _this$props3.min,\n          max = _this$props3.max;\n      var cache = this.internalPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _objectSpread({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this.internalPointsCache.points;\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var state = this.state,\n          props = this.props;\n\n      var nextBounds = _toConsumableArray(state.bounds);\n\n      var handle = state.handle === null ? state.recent : state.handle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.props.onAfterChange(nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    }\n  }, {\n    key: \"pushSurroundingHandles\",\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        // eslint-disable-next-line no-param-reassign\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: \"pushHandle\",\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          // eslint-disable-next-line no-param-reassign\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    }\n  }, {\n    key: \"pushHandleOnePoint\",\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n      // eslint-disable-next-line no-param-reassign\n\n\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: \"trimAlignValue\",\n    value: function trimAlignValue(value) {\n      var _this$state2 = this.state,\n          handle = _this$state2.handle,\n          bounds = _this$state2.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: handle,\n        bounds: bounds,\n        props: this.props\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _this$state3 = this.state,\n          handle = _this$state3.handle,\n          bounds = _this$state3.bounds;\n      var _this$props4 = this.props,\n          prefixCls = _this$props4.prefixCls,\n          vertical = _this$props4.vertical,\n          included = _this$props4.included,\n          disabled = _this$props4.disabled,\n          min = _this$props4.min,\n          max = _this$props4.max,\n          reverse = _this$props4.reverse,\n          handleGenerator = _this$props4.handle,\n          trackStyle = _this$props4.trackStyle,\n          handleStyle = _this$props4.handleStyle,\n          tabIndex = _this$props4.tabIndex,\n          ariaLabelGroupForHandles = _this$props4.ariaLabelGroupForHandles,\n          ariaLabelledByGroupForHandles = _this$props4.ariaLabelledByGroupForHandles,\n          ariaValueTextFormatterGroupForHandles = _this$props4.ariaValueTextFormatterGroupForHandles;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n\n        var mergedTabIndex = tabIndex[i] || 0;\n\n        if (disabled || tabIndex[i] === null) {\n          mergedTabIndex = null;\n        }\n\n        var dragging = handle === i;\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabIndex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames2));\n        return /*#__PURE__*/React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          reverse: reverse,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n      return {\n        tracks: tracks,\n        handles: handles\n      };\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      if (!('value' in props || 'min' in props || 'max' in props)) {\n        return null;\n      }\n\n      var value = props.value || state.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: state.bounds,\n          props: props\n        });\n      });\n\n      if (state.bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === state.bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: props\n          });\n        });\n      }\n\n      return _objectSpread(_objectSpread({}, state), {}, {\n        bounds: nextBounds\n      });\n    }\n  }]);\n\n  return Range;\n}(React.Component);\n\nRange.displayName = 'Range';\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  draggableTrack: false,\n  tabIndex: [],\n  ariaLabelGroupForHandles: [],\n  ariaLabelledByGroupForHandles: [],\n  ariaValueTextFormatterGroupForHandles: []\n};\nexport default createSlider(Range);","map":{"version":3,"sources":["D:/Documents/School Stuff/Web 3/ASG 2/web3asg2/node_modules/rc-slider/es/Range.js"],"names":["_defineProperty","_objectSpread","_toConsumableArray","_classCallCheck","_createClass","_inherits","_createSuper","React","classNames","Track","createSlider","utils","_trimAlignValue","trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","length","ensureValuePrecision","Range","_React$Component","_super","_this","call","startValue","startPosition","prevMovedHandleIndex","internalPointsCache","handlesRefs","dragTrack","positionGetValue","position","getValue","calcValueByPos","closestBound","getClosestBound","index","getBoundNeedMoving","prevValue","nextBounds","onEnd","force","state","removeDocumentEvents","onAfterChange","setState","count","min","max","initialValue","Array","apply","map","defaultValue","_value","_bounds","v","i","recent","key","getSliderLength","calcOffset","saveHandle","h","componentDidUpdate","prevProps","prevState","_this2","_this$props","onChange","currentValue","some","isValueOutOfRange","newValues","isNotControlled","controlledState","forEach","item","Object","keys","data","changedValue","onStart","onBeforeChange","onMove","e","startBounds","pauseEvent","maxValue","minValue","pos","vertical","reverse","Math","ratio","floor","c","oldValue","moveTo","onKeyboard","_this$props2","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","abs","_this$state","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","_this$props3","marks","step","cache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushSurroundingHandles","indexOf","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","_this$state2","render","_this4","_this$state3","_this$props4","prefixCls","included","disabled","handleGenerator","trackStyle","handleStyle","tabIndex","ariaLabelGroupForHandles","ariaLabelledByGroupForHandles","ariaValueTextFormatterGroupForHandles","offsets","handleClassName","concat","handles","_classNames","mergedTabIndex","dragging","className","offset","style","ref","ariaLabel","ariaLabelledBy","ariaValueTextFormatter","tracks","slice","_","_classNames2","trackClassName","createElement","getDerivedStateFromProps","every","Component","displayName","defaultProps","draggableTrack"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport React from 'react';\nimport classNames from 'classnames';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar Range = /*#__PURE__*/function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  var _super = _createSuper(Range);\n\n  function Range(props) {\n    var _this;\n\n    _classCallCheck(this, Range);\n\n    _this = _super.call(this, props);\n    _this.startValue = void 0;\n    _this.startPosition = void 0;\n    _this.prevMovedHandleIndex = void 0;\n    _this.internalPointsCache = void 0;\n    _this.handlesRefs = void 0;\n    _this.dragTrack = void 0;\n\n    _this.positionGetValue = function (position) {\n      var bounds = _this.getValue();\n\n      var value = _this.calcValueByPos(position);\n\n      var closestBound = _this.getClosestBound(value);\n\n      var index = _this.getBoundNeedMoving(value, closestBound);\n\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[index] = value;\n      return nextBounds;\n    };\n\n    _this.onEnd = function (force) {\n      var handle = _this.state.handle;\n\n      _this.removeDocumentEvents();\n\n      if (!handle) {\n        _this.dragTrack = false;\n      }\n\n      if (handle !== null || force) {\n        _this.props.onAfterChange(_this.getValue());\n      }\n\n      _this.setState({\n        handle: null\n      });\n    };\n\n    var count = props.count,\n        min = props.min,\n        max = props.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n\n    var _value = props.value !== undefined ? props.value : defaultValue;\n\n    var _bounds = _value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: props\n      });\n    });\n\n    var recent = _bounds[0] === max ? 0 : _bounds.length - 1;\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: _bounds\n    };\n    return _this;\n  }\n\n  _createClass(Range, [{\n    key: \"calcValueByPos\",\n    value:\n    /**\n     * [Legacy] Used for inherit other component.\n     * It's a bad code style which should be refactor.\n     */\n\n    /* eslint-disable @typescript-eslint/no-unused-vars, class-methods-use-this */\n    function calcValueByPos(value) {\n      return 0;\n    }\n  }, {\n    key: \"getSliderLength\",\n    value: function getSliderLength() {\n      return 0;\n    }\n  }, {\n    key: \"calcOffset\",\n    value: function calcOffset(value) {\n      return 0;\n    }\n  }, {\n    key: \"saveHandle\",\n    value: function saveHandle(index, h) {}\n  }, {\n    key: \"removeDocumentEvents\",\n    value: function removeDocumentEvents() {}\n    /* eslint-enable */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          onChange = _this$props.onChange,\n          value = _this$props.value,\n          min = _this$props.min,\n          max = _this$props.max;\n\n      if (!('min' in this.props || 'max' in this.props)) {\n        return;\n      }\n\n      if (min === prevProps.min && max === prevProps.max) {\n        return;\n      }\n\n      var currentValue = value || prevState.bounds;\n\n      if (currentValue.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.props);\n      })) {\n        var newValues = currentValue.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.props);\n        });\n        onChange(newValues);\n      }\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['handle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _objectSpread(_objectSpread({}, this.state), state);\n\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(position) {\n      var props = this.props,\n          state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = _toConsumableArray(state.bounds);\n\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    }\n  }, {\n    key: \"onMove\",\n    value: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.state,\n          props = this.props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / (maxValue - minValue)), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n\n        return;\n      }\n\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    }\n  }, {\n    key: \"onKeyboard\",\n    value: function onKeyboard(e) {\n      var _this$props2 = this.props,\n          reverse = _this$props2.reverse,\n          vertical = _this$props2.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n            props = this.props;\n        var bounds = state.bounds,\n            handle = state.handle;\n        var oldValue = bounds[handle === null ? state.recent : handle];\n        var mutatedValue = valueMutator(oldValue, props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: handle,\n          bounds: state.bounds,\n          props: props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: \"getClosestBound\",\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    }\n  }, {\n    key: \"getBoundNeedMoving\",\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _this$state = this.state,\n          bounds = _this$state.bounds,\n          recent = _this$state.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    }\n  }, {\n    key: \"getLowerBound\",\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: \"getUpperBound\",\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n      return bounds[bounds.length - 1];\n    }\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      var _this$props3 = this.props,\n          marks = _this$props3.marks,\n          step = _this$props3.step,\n          min = _this$props3.min,\n          max = _this$props3.max;\n      var cache = this.internalPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _objectSpread({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this.internalPointsCache.points;\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var state = this.state,\n          props = this.props;\n\n      var nextBounds = _toConsumableArray(state.bounds);\n\n      var handle = state.handle === null ? state.recent : state.handle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.props.onAfterChange(nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    }\n  }, {\n    key: \"pushSurroundingHandles\",\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        // eslint-disable-next-line no-param-reassign\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: \"pushHandle\",\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          // eslint-disable-next-line no-param-reassign\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    }\n  }, {\n    key: \"pushHandleOnePoint\",\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n      // eslint-disable-next-line no-param-reassign\n\n\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: \"trimAlignValue\",\n    value: function trimAlignValue(value) {\n      var _this$state2 = this.state,\n          handle = _this$state2.handle,\n          bounds = _this$state2.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: handle,\n        bounds: bounds,\n        props: this.props\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _this$state3 = this.state,\n          handle = _this$state3.handle,\n          bounds = _this$state3.bounds;\n      var _this$props4 = this.props,\n          prefixCls = _this$props4.prefixCls,\n          vertical = _this$props4.vertical,\n          included = _this$props4.included,\n          disabled = _this$props4.disabled,\n          min = _this$props4.min,\n          max = _this$props4.max,\n          reverse = _this$props4.reverse,\n          handleGenerator = _this$props4.handle,\n          trackStyle = _this$props4.trackStyle,\n          handleStyle = _this$props4.handleStyle,\n          tabIndex = _this$props4.tabIndex,\n          ariaLabelGroupForHandles = _this$props4.ariaLabelGroupForHandles,\n          ariaLabelledByGroupForHandles = _this$props4.ariaLabelledByGroupForHandles,\n          ariaValueTextFormatterGroupForHandles = _this$props4.ariaValueTextFormatterGroupForHandles;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n\n        var mergedTabIndex = tabIndex[i] || 0;\n\n        if (disabled || tabIndex[i] === null) {\n          mergedTabIndex = null;\n        }\n\n        var dragging = handle === i;\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabIndex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames2));\n        return /*#__PURE__*/React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          reverse: reverse,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n      return {\n        tracks: tracks,\n        handles: handles\n      };\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      if (!('value' in props || 'min' in props || 'max' in props)) {\n        return null;\n      }\n\n      var value = props.value || state.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: state.bounds,\n          props: props\n        });\n      });\n\n      if (state.bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === state.bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: props\n          });\n        });\n      }\n\n      return _objectSpread(_objectSpread({}, state), {}, {\n        bounds: nextBounds\n      });\n    }\n  }]);\n\n  return Range;\n}(React.Component);\n\nRange.displayName = 'Range';\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  draggableTrack: false,\n  tabIndex: [],\n  ariaLabelGroupForHandles: [],\n  ariaLabelledByGroupForHandles: [],\n  ariaValueTextFormatterGroupForHandles: []\n};\nexport default createSlider(Range);"]},"metadata":{},"sourceType":"module"}