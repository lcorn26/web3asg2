{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { fillFieldNames } from \"rc-tree-select/es/utils/valueUtil\";\nvar VALUE_SPLIT = '__RC_CASCADER_SPLIT__';\nexport { fillFieldNames };\n/**\n * Convert entity back to path & options\n * @returns\n */\n\nexport function restoreCompatibleValue(entity, fieldNames) {\n  var path = [];\n  var options = [];\n  var current = entity;\n\n  while (current) {\n    path.unshift(current.data.node[fieldNames.value]);\n    options.unshift(current.data.node);\n    current = current.parent;\n  }\n\n  return {\n    path: path,\n    options: options\n  };\n}\nexport function isLeaf(option) {\n  var children = option.children,\n      node = option.node;\n  var leaf = node === null || node === void 0 ? void 0 : node.isLeaf;\n  return leaf !== undefined ? leaf : !(children === null || children === void 0 ? void 0 : children.length);\n}\n/**\n * We will connect path value to a string. e.g.\n * ['little', 'bamboo'] => 'little__bamboo'\n *\n * zombieJ: It's better to deprecate the same key in the nest tree. Maybe next major version.\n */\n\nexport function connectValue(value) {\n  return (value || []).join(VALUE_SPLIT);\n}\n/**\n * Reverse of `connectValue`\n */\n\nexport function splitValue(str) {\n  return str.split(VALUE_SPLIT);\n}\n/**\n * Fill options with fully value by path to avoid nest entity with same value.\n * Which means we need another round to get origin node back!\n * This is slow perf on large list. We should abandon same value in nest in future.\n */\n\nexport function convertOptions(options, _ref, internalValueField) {\n  var fieldValue = _ref.value,\n      fieldChildren = _ref.children;\n\n  function injectValue(list) {\n    var parentValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return (list || []).map(function (option) {\n      var _objectSpread2;\n\n      var newValue = option[fieldValue];\n\n      if (parentValue) {\n        newValue = connectValue([parentValue, option[fieldValue]]);\n      } else if (typeof newValue === 'number') {\n        // Since we will convert all the value to string, we need get this\n        newValue = String(newValue);\n      }\n\n      var cloneOption = _objectSpread(_objectSpread({}, option), {}, (_objectSpread2 = {}, _defineProperty(_objectSpread2, internalValueField, newValue), _defineProperty(_objectSpread2, \"node\", option), _objectSpread2));\n\n      if (cloneOption[fieldChildren]) {\n        cloneOption[fieldChildren] = injectValue(cloneOption[fieldChildren], newValue);\n      }\n\n      return cloneOption;\n    });\n  }\n\n  return injectValue(options);\n}","map":{"version":3,"sources":["D:/Documents/School Stuff/Web 3/ASG 2/web3asg2/node_modules/rc-cascader/es/util.js"],"names":["_defineProperty","_objectSpread","fillFieldNames","VALUE_SPLIT","restoreCompatibleValue","entity","fieldNames","path","options","current","unshift","data","node","value","parent","isLeaf","option","children","leaf","undefined","length","connectValue","join","splitValue","str","split","convertOptions","_ref","internalValueField","fieldValue","fieldChildren","injectValue","list","parentValue","arguments","map","_objectSpread2","newValue","String","cloneOption"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { fillFieldNames } from \"rc-tree-select/es/utils/valueUtil\";\nvar VALUE_SPLIT = '__RC_CASCADER_SPLIT__';\nexport { fillFieldNames };\n/**\n * Convert entity back to path & options\n * @returns\n */\n\nexport function restoreCompatibleValue(entity, fieldNames) {\n  var path = [];\n  var options = [];\n  var current = entity;\n\n  while (current) {\n    path.unshift(current.data.node[fieldNames.value]);\n    options.unshift(current.data.node);\n    current = current.parent;\n  }\n\n  return {\n    path: path,\n    options: options\n  };\n}\nexport function isLeaf(option) {\n  var children = option.children,\n      node = option.node;\n  var leaf = node === null || node === void 0 ? void 0 : node.isLeaf;\n  return leaf !== undefined ? leaf : !(children === null || children === void 0 ? void 0 : children.length);\n}\n/**\n * We will connect path value to a string. e.g.\n * ['little', 'bamboo'] => 'little__bamboo'\n *\n * zombieJ: It's better to deprecate the same key in the nest tree. Maybe next major version.\n */\n\nexport function connectValue(value) {\n  return (value || []).join(VALUE_SPLIT);\n}\n/**\n * Reverse of `connectValue`\n */\n\nexport function splitValue(str) {\n  return str.split(VALUE_SPLIT);\n}\n/**\n * Fill options with fully value by path to avoid nest entity with same value.\n * Which means we need another round to get origin node back!\n * This is slow perf on large list. We should abandon same value in nest in future.\n */\n\nexport function convertOptions(options, _ref, internalValueField) {\n  var fieldValue = _ref.value,\n      fieldChildren = _ref.children;\n\n  function injectValue(list) {\n    var parentValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return (list || []).map(function (option) {\n      var _objectSpread2;\n\n      var newValue = option[fieldValue];\n\n      if (parentValue) {\n        newValue = connectValue([parentValue, option[fieldValue]]);\n      } else if (typeof newValue === 'number') {\n        // Since we will convert all the value to string, we need get this\n        newValue = String(newValue);\n      }\n\n      var cloneOption = _objectSpread(_objectSpread({}, option), {}, (_objectSpread2 = {}, _defineProperty(_objectSpread2, internalValueField, newValue), _defineProperty(_objectSpread2, \"node\", option), _objectSpread2));\n\n      if (cloneOption[fieldChildren]) {\n        cloneOption[fieldChildren] = injectValue(cloneOption[fieldChildren], newValue);\n      }\n\n      return cloneOption;\n    });\n  }\n\n  return injectValue(options);\n}"]},"metadata":{},"sourceType":"module"}