{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toArray from \"@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport warning from \"rc-util/es/warning\";\nimport { toArray } from './commonUtil';\n\nfunction getKey(data, index) {\n  var key = data.key;\n  var value;\n\n  if ('value' in data) {\n    value = data.value;\n  }\n\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  return \"rc-index-key-\".concat(index);\n}\n\nexport function fillFieldNames(fieldNames) {\n  var _ref = fieldNames || {},\n      label = _ref.label,\n      value = _ref.value,\n      options = _ref.options;\n\n  return {\n    label: label || 'label',\n    value: value || 'value',\n    options: options || 'options'\n  };\n}\n/**\n * Flat options into flatten list.\n * We use `optionOnly` here is aim to avoid user use nested option group.\n * Here is simply set `key` to the index if not provided.\n */\n\nexport function flattenOptions(options) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      fieldNames = _ref2.fieldNames;\n\n  var flattenList = [];\n\n  var _fillFieldNames = fillFieldNames(fieldNames),\n      fieldLabel = _fillFieldNames.label,\n      fieldValue = _fillFieldNames.value,\n      fieldOptions = _fillFieldNames.options;\n\n  function dig(list, isGroupOption) {\n    list.forEach(function (data) {\n      var label = data[fieldLabel];\n\n      if (isGroupOption || !(fieldOptions in data)) {\n        // Option\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data: data,\n          label: label,\n          value: data[fieldValue]\n        });\n      } else {\n        // Option Group\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data: data,\n          label: label\n        });\n        dig(data[fieldOptions], true);\n      }\n    });\n  }\n\n  dig(options, false);\n  return flattenList;\n}\n/**\n * Inject `props` into `option` for legacy usage\n */\n\nfunction injectPropsWithOption(option) {\n  var newOption = _objectSpread({}, option);\n\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get: function get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n\n  return newOption;\n}\n\nexport function findValueOption(values, options) {\n  var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref3$prevValueOption = _ref3.prevValueOptions,\n      prevValueOptions = _ref3$prevValueOption === void 0 ? [] : _ref3$prevValueOption;\n\n  var optionMap = new Map();\n  options.forEach(function (_ref4) {\n    var data = _ref4.data,\n        group = _ref4.group,\n        value = _ref4.value;\n\n    if (!group) {\n      // Check if match\n      optionMap.set(value, data);\n    }\n  });\n  return values.map(function (val) {\n    var option = optionMap.get(val); // Fallback to try to find prev options\n\n    if (!option) {\n      option = _objectSpread({}, prevValueOptions.find(function (opt) {\n        return opt._INTERNAL_OPTION_VALUE_ === val;\n      }));\n    }\n\n    return injectPropsWithOption(option);\n  });\n}\nexport var getLabeledValue = function getLabeledValue(value, _ref5) {\n  var options = _ref5.options,\n      prevValueMap = _ref5.prevValueMap,\n      labelInValue = _ref5.labelInValue,\n      optionLabelProp = _ref5.optionLabelProp;\n  var item = findValueOption([value], options)[0];\n  var result = {\n    value: value\n  };\n  var prevValItem = labelInValue ? prevValueMap.get(value) : undefined;\n\n  if (prevValItem && _typeof(prevValItem) === 'object' && 'label' in prevValItem) {\n    result.label = prevValItem.label;\n\n    if (item && typeof prevValItem.label === 'string' && typeof item[optionLabelProp] === 'string' && prevValItem.label.trim() !== item[optionLabelProp].trim()) {\n      warning(false, '`label` of `value` is not same as `label` in Select options.');\n    }\n  } else if (item && optionLabelProp in item) {\n    result.label = item[optionLabelProp];\n  } else {\n    result.label = value;\n    result.isCacheable = true;\n  } // Used for motion control\n\n\n  result.key = result.value;\n  return result;\n};\n\nfunction toRawString(content) {\n  return toArray(content).join('');\n}\n/** Filter single option if match the search text */\n\n\nfunction getFilterFunction(optionFilterProp) {\n  return function (searchValue, option) {\n    var lowerSearchText = searchValue.toLowerCase(); // Group label search\n\n    if ('options' in option) {\n      return toRawString(option.label).toLowerCase().includes(lowerSearchText);\n    } // Option value search\n\n\n    var rawValue = option[optionFilterProp];\n    var value = toRawString(rawValue).toLowerCase();\n    return value.includes(lowerSearchText);\n  };\n}\n/** Filter options and return a new options by the search text */\n\n\nexport function filterOptions(searchValue, options, _ref6) {\n  var optionFilterProp = _ref6.optionFilterProp,\n      filterOption = _ref6.filterOption;\n  var filteredOptions = [];\n  var filterFunc;\n\n  if (filterOption === false) {\n    return _toConsumableArray(options);\n  }\n\n  if (typeof filterOption === 'function') {\n    filterFunc = filterOption;\n  } else {\n    filterFunc = getFilterFunction(optionFilterProp);\n  }\n\n  options.forEach(function (item) {\n    // Group should check child options\n    if ('options' in item) {\n      // Check group first\n      var matchGroup = filterFunc(searchValue, item);\n\n      if (matchGroup) {\n        filteredOptions.push(item);\n      } else {\n        // Check option\n        var subOptions = item.options.filter(function (subItem) {\n          return filterFunc(searchValue, subItem);\n        });\n\n        if (subOptions.length) {\n          filteredOptions.push(_objectSpread(_objectSpread({}, item), {}, {\n            options: subOptions\n          }));\n        }\n      }\n\n      return;\n    }\n\n    if (filterFunc(searchValue, injectPropsWithOption(item))) {\n      filteredOptions.push(item);\n    }\n  });\n  return filteredOptions;\n}\nexport function getSeparatedContent(text, tokens) {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n\n  var match = false;\n\n  function separate(str, _ref7) {\n    var _ref8 = _toArray(_ref7),\n        token = _ref8[0],\n        restTokens = _ref8.slice(1);\n\n    if (!token) {\n      return [str];\n    }\n\n    var list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce(function (prevList, unitStr) {\n      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));\n    }, []).filter(function (unit) {\n      return unit;\n    });\n  }\n\n  var list = separate(text, tokens);\n  return match ? list : null;\n}\nexport function isValueDisabled(value, options) {\n  var option = findValueOption([value], options)[0];\n  return option.disabled;\n}\n/**\n * `tags` mode should fill un-list item into the option list\n */\n\nexport function fillOptionsWithMissingValue(options, value, optionLabelProp, labelInValue) {\n  var values = toArray(value).slice().sort();\n\n  var cloneOptions = _toConsumableArray(options); // Convert options value to set\n\n\n  var optionValues = new Set();\n  options.forEach(function (opt) {\n    if (opt.options) {\n      opt.options.forEach(function (subOpt) {\n        optionValues.add(subOpt.value);\n      });\n    } else {\n      optionValues.add(opt.value);\n    }\n  }); // Fill missing value\n\n  values.forEach(function (item) {\n    var val = labelInValue ? item.value : item;\n\n    if (!optionValues.has(val)) {\n      var _ref9;\n\n      cloneOptions.push(labelInValue ? (_ref9 = {}, _defineProperty(_ref9, optionLabelProp, item.label), _defineProperty(_ref9, \"value\", val), _ref9) : {\n        value: val\n      });\n    }\n  });\n  return cloneOptions;\n}","map":{"version":3,"sources":["D:/Documents/School Stuff/Web 3/ASG 2/web3asg2/node_modules/rc-select/es/utils/valueUtil.js"],"names":["_defineProperty","_toArray","_toConsumableArray","_typeof","_objectSpread","warning","toArray","getKey","data","index","key","value","undefined","concat","fillFieldNames","fieldNames","_ref","label","options","flattenOptions","_ref2","arguments","length","flattenList","_fillFieldNames","fieldLabel","fieldValue","fieldOptions","dig","list","isGroupOption","forEach","push","groupOption","group","injectPropsWithOption","option","newOption","Object","defineProperty","get","findValueOption","values","_ref3","_ref3$prevValueOption","prevValueOptions","optionMap","Map","_ref4","set","map","val","find","opt","_INTERNAL_OPTION_VALUE_","getLabeledValue","_ref5","prevValueMap","labelInValue","optionLabelProp","item","result","prevValItem","trim","isCacheable","toRawString","content","join","getFilterFunction","optionFilterProp","searchValue","lowerSearchText","toLowerCase","includes","rawValue","filterOptions","_ref6","filterOption","filteredOptions","filterFunc","matchGroup","subOptions","filter","subItem","getSeparatedContent","text","tokens","match","separate","str","_ref7","_ref8","token","restTokens","slice","split","reduce","prevList","unitStr","unit","isValueDisabled","disabled","fillOptionsWithMissingValue","sort","cloneOptions","optionValues","Set","subOpt","add","has","_ref9"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toArray from \"@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport warning from \"rc-util/es/warning\";\nimport { toArray } from './commonUtil';\n\nfunction getKey(data, index) {\n  var key = data.key;\n  var value;\n\n  if ('value' in data) {\n    value = data.value;\n  }\n\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  return \"rc-index-key-\".concat(index);\n}\n\nexport function fillFieldNames(fieldNames) {\n  var _ref = fieldNames || {},\n      label = _ref.label,\n      value = _ref.value,\n      options = _ref.options;\n\n  return {\n    label: label || 'label',\n    value: value || 'value',\n    options: options || 'options'\n  };\n}\n/**\n * Flat options into flatten list.\n * We use `optionOnly` here is aim to avoid user use nested option group.\n * Here is simply set `key` to the index if not provided.\n */\n\nexport function flattenOptions(options) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      fieldNames = _ref2.fieldNames;\n\n  var flattenList = [];\n\n  var _fillFieldNames = fillFieldNames(fieldNames),\n      fieldLabel = _fillFieldNames.label,\n      fieldValue = _fillFieldNames.value,\n      fieldOptions = _fillFieldNames.options;\n\n  function dig(list, isGroupOption) {\n    list.forEach(function (data) {\n      var label = data[fieldLabel];\n\n      if (isGroupOption || !(fieldOptions in data)) {\n        // Option\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data: data,\n          label: label,\n          value: data[fieldValue]\n        });\n      } else {\n        // Option Group\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data: data,\n          label: label\n        });\n        dig(data[fieldOptions], true);\n      }\n    });\n  }\n\n  dig(options, false);\n  return flattenList;\n}\n/**\n * Inject `props` into `option` for legacy usage\n */\n\nfunction injectPropsWithOption(option) {\n  var newOption = _objectSpread({}, option);\n\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get: function get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n\n  return newOption;\n}\n\nexport function findValueOption(values, options) {\n  var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref3$prevValueOption = _ref3.prevValueOptions,\n      prevValueOptions = _ref3$prevValueOption === void 0 ? [] : _ref3$prevValueOption;\n\n  var optionMap = new Map();\n  options.forEach(function (_ref4) {\n    var data = _ref4.data,\n        group = _ref4.group,\n        value = _ref4.value;\n\n    if (!group) {\n      // Check if match\n      optionMap.set(value, data);\n    }\n  });\n  return values.map(function (val) {\n    var option = optionMap.get(val); // Fallback to try to find prev options\n\n    if (!option) {\n      option = _objectSpread({}, prevValueOptions.find(function (opt) {\n        return opt._INTERNAL_OPTION_VALUE_ === val;\n      }));\n    }\n\n    return injectPropsWithOption(option);\n  });\n}\nexport var getLabeledValue = function getLabeledValue(value, _ref5) {\n  var options = _ref5.options,\n      prevValueMap = _ref5.prevValueMap,\n      labelInValue = _ref5.labelInValue,\n      optionLabelProp = _ref5.optionLabelProp;\n  var item = findValueOption([value], options)[0];\n  var result = {\n    value: value\n  };\n  var prevValItem = labelInValue ? prevValueMap.get(value) : undefined;\n\n  if (prevValItem && _typeof(prevValItem) === 'object' && 'label' in prevValItem) {\n    result.label = prevValItem.label;\n\n    if (item && typeof prevValItem.label === 'string' && typeof item[optionLabelProp] === 'string' && prevValItem.label.trim() !== item[optionLabelProp].trim()) {\n      warning(false, '`label` of `value` is not same as `label` in Select options.');\n    }\n  } else if (item && optionLabelProp in item) {\n    result.label = item[optionLabelProp];\n  } else {\n    result.label = value;\n    result.isCacheable = true;\n  } // Used for motion control\n\n\n  result.key = result.value;\n  return result;\n};\n\nfunction toRawString(content) {\n  return toArray(content).join('');\n}\n/** Filter single option if match the search text */\n\n\nfunction getFilterFunction(optionFilterProp) {\n  return function (searchValue, option) {\n    var lowerSearchText = searchValue.toLowerCase(); // Group label search\n\n    if ('options' in option) {\n      return toRawString(option.label).toLowerCase().includes(lowerSearchText);\n    } // Option value search\n\n\n    var rawValue = option[optionFilterProp];\n    var value = toRawString(rawValue).toLowerCase();\n    return value.includes(lowerSearchText);\n  };\n}\n/** Filter options and return a new options by the search text */\n\n\nexport function filterOptions(searchValue, options, _ref6) {\n  var optionFilterProp = _ref6.optionFilterProp,\n      filterOption = _ref6.filterOption;\n  var filteredOptions = [];\n  var filterFunc;\n\n  if (filterOption === false) {\n    return _toConsumableArray(options);\n  }\n\n  if (typeof filterOption === 'function') {\n    filterFunc = filterOption;\n  } else {\n    filterFunc = getFilterFunction(optionFilterProp);\n  }\n\n  options.forEach(function (item) {\n    // Group should check child options\n    if ('options' in item) {\n      // Check group first\n      var matchGroup = filterFunc(searchValue, item);\n\n      if (matchGroup) {\n        filteredOptions.push(item);\n      } else {\n        // Check option\n        var subOptions = item.options.filter(function (subItem) {\n          return filterFunc(searchValue, subItem);\n        });\n\n        if (subOptions.length) {\n          filteredOptions.push(_objectSpread(_objectSpread({}, item), {}, {\n            options: subOptions\n          }));\n        }\n      }\n\n      return;\n    }\n\n    if (filterFunc(searchValue, injectPropsWithOption(item))) {\n      filteredOptions.push(item);\n    }\n  });\n  return filteredOptions;\n}\nexport function getSeparatedContent(text, tokens) {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n\n  var match = false;\n\n  function separate(str, _ref7) {\n    var _ref8 = _toArray(_ref7),\n        token = _ref8[0],\n        restTokens = _ref8.slice(1);\n\n    if (!token) {\n      return [str];\n    }\n\n    var list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce(function (prevList, unitStr) {\n      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));\n    }, []).filter(function (unit) {\n      return unit;\n    });\n  }\n\n  var list = separate(text, tokens);\n  return match ? list : null;\n}\nexport function isValueDisabled(value, options) {\n  var option = findValueOption([value], options)[0];\n  return option.disabled;\n}\n/**\n * `tags` mode should fill un-list item into the option list\n */\n\nexport function fillOptionsWithMissingValue(options, value, optionLabelProp, labelInValue) {\n  var values = toArray(value).slice().sort();\n\n  var cloneOptions = _toConsumableArray(options); // Convert options value to set\n\n\n  var optionValues = new Set();\n  options.forEach(function (opt) {\n    if (opt.options) {\n      opt.options.forEach(function (subOpt) {\n        optionValues.add(subOpt.value);\n      });\n    } else {\n      optionValues.add(opt.value);\n    }\n  }); // Fill missing value\n\n  values.forEach(function (item) {\n    var val = labelInValue ? item.value : item;\n\n    if (!optionValues.has(val)) {\n      var _ref9;\n\n      cloneOptions.push(labelInValue ? (_ref9 = {}, _defineProperty(_ref9, optionLabelProp, item.label), _defineProperty(_ref9, \"value\", val), _ref9) : {\n        value: val\n      });\n    }\n  });\n  return cloneOptions;\n}"]},"metadata":{},"sourceType":"module"}